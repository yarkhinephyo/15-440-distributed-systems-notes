**Characteristics of RPC**: Synchronous transfer of control. Invocation syntax matches the server's language.

**Limitations of RPC**

<ins>No shared address space</ins>

1. Global data cannot be shared
2. Large data structures can be expensive for marshalling
3. Only call by value results

<ins>Delayed binding of RPC</ins>

1. Runtime link errors are possible
2. Multiple servers may support the same interface and clients may talk to more than one server

<ins>Failure independence</ins>

1. Client and server can die independently which requires more complex logic to handle failures

**Stub routines**

Code generated by the stub generator from the interface definition. Custom interface Definition Language (IDL) is used to specify the details about RPC such as the name and parameters.

<ins>Client Stub</ins>

1. Invoked by user code as local procedure
2. Packs parameters into a request-packet
3. Sends to the server and blocks until a reply or failure
4. Unpack response-packet into output parameters
5. Return to user code

<ins>Server Stub</ins>

1. Invoked when a request arrives
3. Unpacks request-packet for the local procedure
4. Determine which local procedure to call
5. Invokes local server's procedure
6. Packs response parameters into response-packet
7. Sends to the client and waits for another request

![](images/Pasted%20image%2020230429104549.png)

**Exactly-one Semantics**

- Old replies and sequence numbers have to be kept forever to ensure that no duplicate computation is done.
- The data has to be saved in non-volatile memory to preserve across server crashes.
- Partial computations have to be undone during crash recovery.
- RPC calls would block indefinitely until there is a reply.

Not appropriate in many use cases as there is performance penalty and potential indefinite blocking.

**At-most-once Semantics**

- Timeout is declared after a certain delay.
- No indefinite blocking.
- Executed exactly once on success and at most once on timeout.
- Old replies and sequence numbers have to be kept forever to ensure that no duplicate computation is done.

There may be orphaned computations on the server when network failure occurs after the client sends the request.

**At-least-once Semantics**

- Requires the operation to be idempotent.
- Implementation can be completely stateless on the server side.

**End-to-end Reasoning**

Functions placed at low levels of a system may be redundant or of little value when compared with the cost of providing them at that low level.

<ins>Example</ins>: RPC on TCP rather than UDP does not simplify exactly-once implementation as server would still have to eliminate duplicate TCP connections. It worsens the best-case performance due to unnecessary ACKs.

**Law of Queueing Theory**

You can only optimize at most 2 out of 3.

1. <ins>Utilization</ins> - Use of CPU, network, disk.
2. <ins>Latency</ins> - User experience.
3. <ins>Freedom</ins> - Orchestrated or un-orchestrated arrivals.
